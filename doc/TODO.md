### TODOs

- good enough release
- init command, bootstrap create tables, create config and put in db.
    - or just go generate
    - config toml or db. or json
    - dump-config to toml, maybe json
    - load-config 
    - start --config a --db\, minimize the number of flags
- if in db config, how to edit the easiest, toml?
- reset email 
- reset password
- add logger
- minify html, 5% space.
- request email verification must be logged
- i think public to static 
- second db interface for custom 
- cache and other headers from assets use a middlware for api we have a map that we appli in response
    - try to be consistent
    - 'static' form html, js, css ... and api for dinamic 
    - gzip header moev to response_headers
- document magix numbers of sketch. move it to new package, configuration
- maek method/global middleware before mux. block ip documentation, proper conf. fix TODO 
- verify addresses paths shoudl be random or pseudo random?
- revamp shell tests.
- CORS 
- updatebenchmark
- block ua: cache db,  
- block jwt: cache db,  
- block referrer
- multidomain  
- store?, just a sync.Map, do not overcomplicate,
- a global mimetype middleware?, allowing only supported server json, html, css, js,
    - we already have a mimetype method for handlers. good practices while making a handler is 
        - use authenticate (do i need auth)
        - use mimetype (what mimetype do i allow)
        - method (already handled by router)
- make defensice goroutine or middleware??? has and checks req/second and maybe server load, dinamically add block modules.
- block methods automatically, win against router?
- in process litestream 
- rethink payload job unique, per customer or payloads should have customer info
- document middleware politic, if you have to write in the context, you shoudl not be a middleware.
	- the first middleare post serverHttp code is the last observer.
- implment password reset, email change
- safe html headers middleware, method
- register with password after oauth2
- decide about configuration
- superuser? just ssh?
- endpoints api configurable in conf
- metrics
- sheurl hadcoded https. should be configurable if srver http under proxy TLS like cloudflare
- downtime page schedule, all routes to, lock db ...
- error in trhe sequnce of step f ex register can let inconsitent state, ex
    - error after inserting job, we have user in db but no varification 
- generate new jwt register 
- jwt invalidation go tests
- integration sh test post invalidation jwt 
- test requestverification: test also insertion in queue, now only mock nil.
- more bash test all endpoints
- test moe all to dbsetup
- code review jwt tests
- zombiezen, impl pool with timeout, split in files. 
- zombiezen, crawshaw, use stmp.step, handling of conn with setinterrupt and timeout
- httprouter params to servemux $ 
- tls
- hardening: add headers CORS, etc
- add toml conf and config struct, add struct to app, router, cache
- document design in doc. why all decision.
- frontend integration with fs embed 
- integrate 3 party middleware
- add prometheus.
- s3 integration
- proper error handling from sqlitex, timeouts.
- document performance read/write 
- rand source in app. performacen rand
- make command line to copy files and perform changes in the codes based on preferences. maybe using generate
- More backends: badger and boldb
- the command (maybe based on configuration) creates dir, copy only needed packages and inserts custom code pa

### done

- callback.html copy to puclic
- safe api heders, html headers middleware 
- general rate limit -> no 
- general rate limit per ip -> no, just protect server of mild attacks with blocking, api resources is ACL
- gzip, go:generate gz all files html and javascript all files and put in FS, when serving set Content-Encoding: gzip. we avoid dinamyc gzip
    - FS
    - start with js SDK
	- make maybe package restinpieces only to have generate.go, without build ignore, there we can put embed for FS and migrations files for initialization
	- go:generate for add dbs in sqlite instead of command bootstrap?
	- go:generate for config generator toml for example
	- maybe simple make
- tools for go generate
- static assets, FS cache control. 
    - all assets are go generated
- html no inline?
- static versioning, net/html to parse ans sustitute with versioned js and css
- block non wnanted mimetypes: with per handler endpoint method, not allowing empty. document each handler 
    - the mimetype required by a handler, is part of the logic of the handler. it should be handled there. document
    - but still endpoints shoudl enforce its allowed mimetype. method like auth mimetype(allowed []) with default json?
    - a mimetype ddos: it 
    - allow empty?
- block ip, protecting server: mild DDos
    - CMS https://github.com/shenwei356/countminsketch
        - 2000 x 10 make default 160 k at startup of the middleware
        - rebuild afterx min
        - rebuild after window 10 min?
        - maybe make 2 
        - put ip in cache with TTL 
        - first check blocked ip.
        - https://www.geeksforgeeks.org/count-min-sketch-in-java-with-examples/
        - non concurrent!
    - top k skets https://github.com/keilerkonzept/topk?tab=readme-ov-file#top-k-sketch
        - has sliding window, that is better.  
    - jsut cache TTL
       - create key per minute: increment and get mod(time)+ip, if > threhhold block 
       - does not have increment.
       - https://github.com/dgryski/go-tinylfu ?
- remove experd in return from function, get it from config
- sdk move request to class, rename imported classes, bundle eliminates collisions. 
	- how to extend the sdk with enpoints   
- consistency js keys auth local storage.
- move html to test/html
- simple dist bundle for js, maybe FS, make, generate
- fix harcoded api endpoints 
    - html pages associeted with verify confirm
    - js files, we could do a /list-enpoints
- auth in a fucntion instead of middleware? easy to reason for handlers 
    - auth is too important to let other part two handle invalidation and put something in the request.
    - handler declare it is authenticated endpoint by requirin Authenticate() func
    - Authenticate(req)(user,error) is app funcion can get db, cache etc.
    - handlers are authenticated or not
    - jwtvalidate middleware, block if invalid
    - AuthenticatedUser() function with nil user and error, (user , error)
- js sdk, fasade for endpoints refreshAuth, look up local storage, if not made call to discovery endpoints.
    - with map, call the requestJson or requestJsonAuth
- application/json just one
- move  app package to core, 
- security headers and litle things that write simple thing to heaaders are functions not middleware
- create reposnse package with errors, headers.go,  amaybe request
- signal, add baseContext
- /impl backend job to verification email
    - reads from job_queue 
    - generates token
    - put in user tokenkey????? no is jwt
    - sends email with mailyak
    - status processinnf in job, each job has steps laststep issaved in jobqueue steps are label with humman code explanation
    - /confirm-verification endpoint 
        - returns 204, or error 400
        - get generated token from db, compares to token from request
- domain localhost variable shoul be dinamic 
- update all errors to our format, update if needed  ClientResponseError
- Implementaion of race condition-free auth-with-oauth2
- ~~timeouts in server~~
- ~~move gratefull shutdown to server.go~~
- ~~integrate, benchmark ristretto~~
- ~~signal to stop handling~~
- ~~write normal pool insert~~
- ~~encapsulate router, maybe later interface~~
- ~~context/application package~~
- ~~context request~~
- ~~model~~
- ~~sqllite with cranshaw~~
- ~~remove reference to "github.com/julienschmidt/httprouter" in handlers. To
  know the key in the context, we should not need the router. After router
  init, find the context key and pass to the app. or just harcoded conf in toml
  Or just used explicite params.~~
- make sh files inside repo for testing with curl different parst
    - generate jwt sh maybe also signing method
        - generate token 1`
    - testendpoint send curl with different tokens. 
    - provide file in docs to test all of them combined
- handling of flow for oauth2/passwords:
	- Implemetation Conclusions
		- add field externalAuth: string. if string contains oauth2, that means
		  this row email was used in combination with oauth2 of some/many provider.
			- structure of field to allow for future  mfa:
				- no mfa: auth1,auth2 (password auth excluded) where , has semantic of AND, presence of "," means no mfa
				- mfa: auth1:auth2, presence of : means mfa, 
		- name of field shoudl suggest alternativeAuth, meaning basic pasword auth is excluded here, 
			- externalAuth, OTP per email, oauth2, OTP app. all require something external to the app. 
		- User struct should have hasMfa method, mfaAuthfirst, mfaAuth2Second, hasAuthWithPassword, hasAuthWithOauth2 
			- also method AuthMethods() contain password, by lookin presence of password
		- we do not want to write redundant info in that field, existence of password is enough to know auth with password
			
    - testcases to test, 
        - user register with password, login later with oaut2 with the same email -> we shoudl update the External
        - user with two auth method and refresh endpoint: it has password, 
        - 
	- we could implment in the future mfa, do not forget with the following considerations.
	- a user can log with many oauth2 providers IF they all are realted to one email account
	- email is always UNIQUE for the user, we do not allow two emails, 
		- two emails would be a nightmare, email is the channel of communication with the user.
		- ex login with email1 and password, and oauth2 provider that ahs other email should not be possible
	- oauth is passwordless, we should maintain that in the Users table, password field is the key field to controls the endpoints interaction
	- jwt signing key should be possible without password
		- make tests 
	- if user has password login and uses that same email with a oauth2, that is posssible, we just add auth field oauth2, YES
	- if user request /request-email-change, whithout password,  it should be denied with error indicating not possible
		- we could say request a request-password-reset if your intention is to login in the future with password
		- lets say user uses oauth2 google, want to get rid of that:
            - Users can only change password if they have one, they can though register with email!!!!!!!!!!!!!!!!! YES
			- only solution is request-password-reset, NO ->>> the user can now try register with passsword if exist email but no password we allow it and do no send email verification
				- the UI can see user has no password and change text of
				  request-password-reset, "Allow also login with password"
	- if user request /request-verification whitout password, we should show
	  alreadu validated, because we only allow exterval auth methods that produce
	  verified email
    - if user login with auth2 after having password, that is possible we must update only ExternalAuth
	- if user request request-password-reset whithout password, we allow it, it is the way to possibly remove the oauth2 provider
		- there must be a way to transition from oauth2 to password based auth
		- this produce a user that can login with oauth2 and with password 
		- if that user after that change the email, than it is possible, but
		  that obviosly invalidate the oauth2 one. Login with oauth2 will create another user. Could be a surprise for the user.
				- with the externalAuth set to oauth2 we say the user "you are
				about to change the email but that will invalidate login with oauth2 providers asssociated with that email"
					- we do not list the providers, it could be many if user hast same email by many.
	- if user uses many oauth2 providers (with same email) we do not update avatar, name etc
			- after first login/register the name avatar is appropieated by the app. in the future it can or can not be edited
	- we could allow delete password, only having alternative login nmethod like oauth2.
	- double pasword, oauth2?
		- only through request-password-reset 
	- when first auth-with-oauth2, ie register with oauth2, we do not allow it if email not validated by oauth2 provider
		- oauth2 registration always produce verified true
	- db methods shoudl not make validation, handlers should make it, like create user with verified and no password.

- mapping go struct <=> sqlite queries (insert queries, only those use default)
	- using crawshaw Exec only allow for determined number of placeholder
	- example a insert for createUser, we want sqlite to write the default created, updated. but the go struct is empty
		- each method (query) should write all values in go 
		- each method determine the list of arguments, which argumetn will update, and the number of placeholders.
			- createUser for oauth2
				- created and updated do not write

			- createUser for password
				- created and updated do not write
	- i think the idea is
		- check the schema definition, look for DEFAULT in schema that are not zero
			- if schema has a default it means it wants to write it, let it
		- for each query, method, determine which values come from go, and which ones are writen by the db
		- it should check all posssible callers of the method
			- oauth2 creation of user has avatar, password no -> but default is fine argument
			- all creation we let dn write
		- normally if the zero value in go is not the zero value in db. do not let go write it.*as always we are taking about INSERTS)

- POST handlers that always run. ancapsulate alice.
    - h.WithMiddlewareChain(chain1).WithMiddleware(m1,m2).WithMiddlewareChain(chain2).WithObservers(o1,o2)

    - NewMiddlewareChain(a,b,c,d)
    - Bind() // Bind to handler
    - BindPostHandlers()
    - WithObservers
    - mainChain = handler.WithMiddleware(a,b,c) or
    - mainChain = handler.WithMiddleware(middlewareChain)
    - finalHandler := WithObservers(mainChain, handlerB, handlerC, handlerD)
    - h.WithMiddleware().WitObservers
    - 
- refresh jwt
- User schema, remove tokenKey
- jwt signing key invalidation
