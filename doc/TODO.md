### TODOs

- sdk visibility, own route
- move router httprouter to repo
- renew-jtw-secrets like create-app, creates a new config
- rollback config 
- create-app shoudl create age key.
- user can add jobs, we want to get rid of acme dependencies
    - acme renewal does not belong in main repo 
    - we can return the scheduler
    - remember the handler of the user may use app db or other things
    - a property of the server
    - server has GetJobExecutor().Register(myHandler)
    - or better AddJobHandler()
        - server has executor
            - executor has a Register()
- start server dbfile consistence
- acme is a scheduler job. remove to own repo
- disable standard routes
- is a framework, clear workflow  -> examples repo. od use of the features
- nocache? what about BlockIp.
- test litestream
- router: create router.Chains type
- good enough release
    - litestream file or/and s3 
    - basic metrics 
		- https://github.com/prometheus/client_golang
		- just requets/second. 
    - notification basic
    - superuser workflows
		- scripts
	- all shell test 
	- unit test
	- code review
	- workflow for recovery, 
	- basic framework use examples repo, with examples of features.
- robots.txt
- script insert-job. --type 
- config reload
- race detection
- scheduler recurrent jobs
	- has tick
		-  config based 
            - not only check entries, but check config? Nee 
		- scheduler writes new after completion of last
            - on startup scheduler creates recurrent jobs entries based start time.
		    - has start and duration and recurrent
			    - recurrent if recurernt scheduler markSuccesful and creates next
	- notification executor handler 
- basic metrics 
	- https://pkg.go.dev/runtime/metrics
    - go ones
    - basic superuser endpoint
        - or not jsut notification
    - some made in preRouter, conunters etc
    - no prometheus page
- script modify-config, ??
	- read from db, decode toml, build config struct?
- superuser
	- basic idea is superuser has simple scripts, to activate disable things. add jobs. etc
	- hourly X ok telegram message
	- more detailed report 
- 10% reduction in req/sec from htttp, to https refresh auth, with block ip
- password reset if no password ie oauth2 user => no only register with email
- verify email for oauth -> yes verifed
- corfirmation, spam sending the same right jwt 
- endpointsw discovery has no update each time.
- assets integrity, bundler 
- confirmation endpoints spam attacks
	- attacker with valid email token (1 hour) can spam until token expiration
	- this is jwt attack, 
	- damage is 1 read 1 idempotent write
	- for confirmation and expensice path, maybe hash the page (or paht) in cache with ttl, already requested try in a minutes
- request change endpoints spam attacks TODO
- request email verification must be logged
- cache and other headers from assets use a middlware for api we have a map that we appli in response
    - try to be consistent
    - 'static' form html, js, css ... and api for dinamic 
    - gzip header moev to response_headers
- document magic numbers of sketch. move it to new package, configuration
- verify addresses paths shoudl be random or pseudo random?
- revamp shell tests.
- CORS 
- in process litestream 
- document middleware politic, if you have to write in the context, you shoudl not be a middleware.
	- the first middleare post serverHttp code is the last observer.
- superuser? just ssh?
- metrics
	https://github.com/prometheus/client_golang
- sheurl hadcoded https. should be configurable if srver http under proxy TLS like cloudflare
- downtime page schedule, all routes to, lock db ...
- error in trhe sequnce of step f ex register can let inconsitent state, ex
    - error after inserting job, we have user in db but no varification 
- generate new jwt register 
- jwt invalidation go tests
- integration sh test post invalidation jwt 
- test requestverification: test also insertion in queue, now only mock nil.
- more bash test all endpoints
- code review jwt tests
- zombiezen, impl pool with timeout, split in files. 
- httprouter params to servemux $ 
- hardening: add headers CORS, etc
- document design in doc. why all decision.
- document performance read/write 
- the command (maybe based on configuration) creates dir, copy only needed packages and inserts custom code pa
- minify html, 5% space. if we already have gzip
    - https://github.com/tdewolff/minify?tab=readme-ov-file#html 
    - https://github.com/privatenumber/minification-benchmarks?tab=readme-ov-file#%EF%B8%8F-minifier-showdown

### Maybe
- NewWithConfig(restinpieces.Config{
- updatebenchmark: to own paclkage resuse modernc and 
- modernc?
- add prometheus.
- s3 integration
- cache alternative syncMap, no garbage collection, noOP
- propably multidomain
- ETag or Last-Modified: Enables efficient cache validation for performance. -> no: user
    - no we are talking about html.
    - at most a weak etag like deploy tag
    - maybe max-age 1 hour in cache control
    - opinionaated, user can make its own
- block ua: cache db,  
- block jwt: cache db,  
- block referrer
- rand source in app. performacen rand
- zombiezen, crawshaw, use stmp.step, handling of conn with setinterrupt and timeout

### done

- litestream is a addon, it has own config structs.
    - it shoudl bea ble to use age key and load in db.
    - db config has types.
- bug oauth2 redirect
- unset age key file contents 
- age toml encript?    
    - changes is, 
        - we do not allow env vars.
            - just db and age key file
        - say hwo to paste certs etc 
        - no env file
        - no example toml file
    - we start we want only a db and a age key file.
    - remove the example toml,
    - migrate to pelletier 
        - https://pkg.go.dev/github.com/pelletier/go-toml/v2#example-Marshal-Commented Comments in Marshall!!!
    - create-app app.db
        - generates default based on config struct with comments
        - generates public key pair,
            - where to save the public?
        - encript the toml payload 
        - generates app.db structure 
        - writes encripted toml in BLOB field 
        - dump-conf command decript toml and present file
            - edit with favorite editor
        - update-conf config.toml
        - add-cert is decrypt decode, in go load file, encode to toml encrupt with with, db. 
        - add-oauth2
        - add-acme
        - certificates go in the config struct, no files allowed
    - in db encrypted.
    - we have to get rid of toml file example, only db and age key. 
    - scafold:on first run. default are written smtp disabled, no aouth2, no acme.
        - it creates age key pair, 
        - and a dump of config struct in toml
    - workflow config is in db encrypted.
        - we do not allow config in the command line, if user want they make demselves
    
- sdk endpoint
	- move to own repo?
	- rename just to show the sdk
- control new features, they can go in other projects/packages
- tls: 80 redirect
- move cwashaw to repo
- litestream
    - new repo. server service. server handles stop and start.
    - server.AddService()
	- in binary, can be configured.
	- only file or s3/b2
	- ssh client scp in intervals. flag ssh address + directory
	- with age.
- if tls, handle automatic redirection to https
	- redirect server
- prepareConn explicite
	- busy timeout and sync normal, for Performance
- config validate BaseURL basic things of the config on Load
- core. Capitalize for export, response, request and some middleware and 
    - auth middleware and handlers, are lowercase
-  config on init all secrets are loading in memory
    - handler: write in the db istead of file mangling
	- if tls set reader
    - refactor multiple lego dns provider
    - context for timneout in the handler
    - are resource file []byte save in new table.
    - initial cert, lego?
    - account ACME user. HOw to change password? what happens if lost.
    - build without https support? ACME dependencies  
	- get set in db
	- Test your setup with tools like ssllabs.com or testssl.sh
- default zombiezen 
- blockip move
- Move validate claims to request jwt 
	- not really crypto
- order in init/main. modular. Brainstrom 
- maek method/global middleware before mux. block ip documentation, proper conf. fix TODO 
- mantenance if html request css , if json responde json
- mantenance page 
    - https://developers.cloudflare.com/rules/snippets/examples/maintenance/
- tls 
- mantenance
    - if path api.
    - if not harcoded page
    - mantenance page service redirect
- rethink payload job unique, per customer or payloads should have customer info
- password change test with real smtp  
- add toml conf and config struct, add struct to app, router, cache
- proxy, app clear wiring
    - proxy design is overkill, 
        - move to app
        - just initailiza alwya the sketch
        - check conf to use or not
- content headers TLS
	- Strict-Transport-Security: max-age=63072000; includeSubDomains
	- in proxy/app method we know conf enable tls. set header
- make command line to copy files and perform changes in the codes based on preferences. maybe using generate
- maintenance middleware: 503 Retry-After: 3600
	- we can not avoid goroutine
    - global middleware, wraps router
        - Block ip method
        - maintenance
	- we have a handler struct with mthods that can be applied before passing to router
	- global custom mux that embed router and modify just host in the request
		- standar mux/route is given just a new request
- tls
- Strict-Transport-Security: Enforces HTTPS, preventing downgrade attacks. Essential for TLS.
- CSP frame-ancestors directive: Prevents clickjacking. Needs to be added explicitly to your CSP.
	- Content-Security-Policy: default-src 'self'; frame-ancestors 'none'
	- frame-ancestors 'none' not covered by default-src 'self'
- X-Content-Type-Options: Prevents MIME-sniffing attacks. Simple, robust addition.
- APP
	- app is handler?
		- is given to the server
		- servehttp executes Proxy that execute as next the Path router
		- we have WithProxyEmpty, no proxy is one, it has features activated or not, WithProxy(pruxy)
- app, server dicotomy
- sdk, if http, call http, if https call https
- certs in db
- config fields omit, toml 
- decide about configuration
- add logger
    - no slog.SetDefault(slog.New(myHandler))
    - A "multiplexer" handler is a good approach.
    - stdout Handler: slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{Level: dynamicLevel}) or slog.NewJSONHandler(os.Stdout, ...) (JSON is often better for systemd/journald as it preserves structure).
    - SQLite Handler: This needs careful implementation (async recommended).
    - none handler
	- Global State?: Relies on package-level global state. This makes testing significantly harder.
	- For most applications, especially web services, APIs, or any system where
	testability and maintainability are important, injecting the slog.Logger
	instance is the strongly recommended best practice.
- store?, just a sync.Map, do not overcomplicate,
- make defensice goroutine or middleware??? has and checks req/second and maybe server load, dinamically add block modules.
- endpoints api configurable in conf
- implment password reset, email change
- safe html headers middleware, method
- register with password after oauth2
- bug in google login missing client id
    - also github is being presented
- fileserver in library? -> no. examples repo, sdk
- Route struct? Register without route? User must import router -> Documentation
    - user can use Handle
    - or import Route package framework // Document
- drivers init string PRAGMAS, flags?
- remove dbfile from new, only enforce pool is correct, only db needs to know the dbfile
- config file or db
- No hot reloading.
- helper method DeafaultDbCrawsawPool
    - you need a db clietn for the application. It mus be shared. WAL. Use Default or make your own,
        - warning 
- dbauth, dbQueue, 
- remove channel writer 
- remove dev tag
- app.close method overkill
- DbLifecycle, DbProvider naming
- Bug: users with aouth2 and password. Refresh
- request password change html requires email form
- user request pasword and email change at the same time. possible collions?
	- both processes will change auth jwt signing key
	- token in email for passord reset is signed with old password adn old email
	- token in email for email change is signed with old email  
    - user click first email for password change, success, makes invalid password reset token
    - user click first email for password reset, success, makes invalid change email token
- generally sending emails is expensive operation, check it is rate limited
- email change payload 
	- somewhre in flow tell user old email is also used for oauth2  -> email
- reset email 
- reset password
- password reset without verified email?
	- login oririnates send email, expensice operation
	- it can now ask for password change, that creates another send email
	- block
- email change payload should be user id, 
	- being email the user can succesfully chagne email with different emails
	- it can not rotate, it must be a new email each bucket.
	- but still, enforce user level
	- enforment is User can only request 1 mail change per time
	- enforment is User can only request 1 password reset  per time
- check workflow change email
    - do not allow change if old not verified
- one two handler per file 
- verification email cooldown, idea is not to send email
- password reset logic, unique in job is not enough
    - we want the user to do a reset each two hours, ideally wihtout cache
    - payload put email type and number of bucket of two hours
    - user tries to request in the next two hours => conflict RequestPeriod try later
        - user tries to receive, to make us write email. we only allow one per throttle 
        

    - job completed, record present, the system do no let more password reset request
        - user shoudl probably do all request that it wants. we try to not overcomplicate
        - or add some cache? 
        - ideally without cache.
        - atack with a know email in system
    - job deleted after completion 
    - paswords reset each two hours
- bug api headers
- i think public to static 
- callback.html copy to puclic
- safe api heders, html headers middleware 
- general rate limit -> no 
- general rate limit per ip -> no, just protect server of mild attacks with blocking, api resources is ACL
- gzip, go:generate gz all files html and javascript all files and put in FS, when serving set Content-Encoding: gzip. we avoid dinamyc gzip
    - FS
    - start with js SDK
	- make maybe package restinpieces only to have generate.go, without build ignore, there we can put embed for FS and migrations files for initialization
	- go:generate for add dbs in sqlite instead of command bootstrap?
	- go:generate for config generator toml for example
	- maybe simple make
- tools for go generate
- static assets, FS cache control. 
    - all assets are go generated
- html no inline?
- static versioning, net/html to parse ans sustitute with versioned js and css
- block non wnanted mimetypes: with per handler endpoint method, not allowing empty. document each handler 
    - the mimetype required by a handler, is part of the logic of the handler. it should be handled there. document
    - but still endpoints shoudl enforce its allowed mimetype. method like auth mimetype(allowed []) with default json?
    - a mimetype ddos: it 
    - allow empty?
- block ip, protecting server: mild DDos
    - CMS https://github.com/shenwei356/countminsketch
        - 2000 x 10 make default 160 k at startup of the middleware
        - rebuild afterx min
        - rebuild after window 10 min?
        - maybe make 2 
        - put ip in cache with TTL 
        - first check blocked ip.
        - https://www.geeksforgeeks.org/count-min-sketch-in-java-with-examples/
        - non concurrent!
    - top k skets https://github.com/keilerkonzept/topk?tab=readme-ov-file#top-k-sketch
        - has sliding window, that is better.  
    - jsut cache TTL
       - create key per minute: increment and get mod(time)+ip, if > threhhold block 
       - does not have increment.
       - https://github.com/dgryski/go-tinylfu ?
- remove experd in return from function, get it from config
- sdk move request to class, rename imported classes, bundle eliminates collisions. 
	- how to extend the sdk with enpoints   
- consistency js keys auth local storage.
- move html to test/html
- simple dist bundle for js, maybe FS, make, generate
- fix harcoded api endpoints 
    - html pages associeted with verify confirm
    - js files, we could do a /list-enpoints
- auth in a fucntion instead of middleware? easy to reason for handlers 
    - auth is too important to let other part two handle invalidation and put something in the request.
    - handler declare it is authenticated endpoint by requirin Authenticate() func
    - Authenticate(req)(user,error) is app funcion can get db, cache etc.
    - handlers are authenticated or not
    - jwtvalidate middleware, block if invalid
    - AuthenticatedUser() function with nil user and error, (user , error)
- js sdk, fasade for endpoints refreshAuth, look up local storage, if not made call to discovery endpoints.
    - with map, call the requestJson or requestJsonAuth
- application/json just one
- move  app package to core, 
- security headers and litle things that write simple thing to heaaders are functions not middleware
- create reposnse package with errors, headers.go,  amaybe request
- signal, add baseContext
- /impl backend job to verification email
    - reads from job_queue 
    - generates token
    - put in user tokenkey????? no is jwt
    - sends email with mailyak
    - status processinnf in job, each job has steps laststep issaved in jobqueue steps are label with humman code explanation
    - /confirm-verification endpoint 
        - returns 204, or error 400
        - get generated token from db, compares to token from request
- domain localhost variable shoul be dinamic 
- update all errors to our format, update if needed  ClientResponseError
- Implementaion of race condition-free auth-with-oauth2
- ~~timeouts in server~~
- ~~move gratefull shutdown to server.go~~
- ~~integrate, benchmark ristretto~~
- ~~signal to stop handling~~
- ~~write normal pool insert~~
- ~~encapsulate router, maybe later interface~~
- ~~context/application package~~
- ~~context request~~
- ~~model~~
- ~~sqllite with cranshaw~~
- ~~remove reference to "github.com/julienschmidt/httprouter" in handlers. To
  know the key in the context, we should not need the router. After router
  init, find the context key and pass to the app. or just harcoded conf in toml
  Or just used explicite params.~~
- make sh files inside repo for testing with curl different parst
    - generate jwt sh maybe also signing method
        - generate token 1`
    - testendpoint send curl with different tokens. 
    - provide file in docs to test all of them combined
- handling of flow for oauth2/passwords:
	- Implemetation Conclusions
		- add field externalAuth: string. if string contains oauth2, that means
		  this row email was used in combination with oauth2 of some/many provider.
			- structure of field to allow for future  mfa:
				- no mfa: auth1,auth2 (password auth excluded) where , has semantic of AND, presence of "," means no mfa
				- mfa: auth1:auth2, presence of : means mfa, 
		- name of field shoudl suggest alternativeAuth, meaning basic pasword auth is excluded here, 
			- externalAuth, OTP per email, oauth2, OTP app. all require something external to the app. 
		- User struct should have hasMfa method, mfaAuthfirst, mfaAuth2Second, hasAuthWithPassword, hasAuthWithOauth2 
			- also method AuthMethods() contain password, by lookin presence of password
		- we do not want to write redundant info in that field, existence of password is enough to know auth with password
			
    - testcases to test, 
        - user register with password, login later with oaut2 with the same email -> we shoudl update the External
        - user with two auth method and refresh endpoint: it has password, 
        - 
	- we could implment in the future mfa, do not forget with the following considerations.
	- a user can log with many oauth2 providers IF they all are realted to one email account
	- email is always UNIQUE for the user, we do not allow two emails, 
		- two emails would be a nightmare, email is the channel of communication with the user.
		- ex login with email1 and password, and oauth2 provider that ahs other email should not be possible
	- oauth is passwordless, we should maintain that in the Users table, password field is the key field to controls the endpoints interaction
	- jwt signing key should be possible without password
		- make tests 
	- if user has password login and uses that same email with a oauth2, that is posssible, we just add auth field oauth2, YES
	- if user request /request-email-change, whithout password,  it should be denied with error indicating not possible
		- we could say request a request-password-reset if your intention is to login in the future with password
		- lets say user uses oauth2 google, want to get rid of that:
            - Users can only change password if they have one, they can though register with email!!!!!!!!!!!!!!!!! YES
			- only solution is request-password-reset, NO ->>> the user can now try register with passsword if exist email but no password we allow it and do no send email verification
				- the UI can see user has no password and change text of
				  request-password-reset, "Allow also login with password"
	- if user request /request-verification whitout password, we should show
	  alreadu validated, because we only allow exterval auth methods that produce
	  verified email
    - if user login with auth2 after having password, that is possible we must update only ExternalAuth
	- if user request request-password-reset whithout password, we allow it, it is the way to possibly remove the oauth2 provider
		- there must be a way to transition from oauth2 to password based auth
		- this produce a user that can login with oauth2 and with password 
		- if that user after that change the email, than it is possible, but
		  that obviosly invalidate the oauth2 one. Login with oauth2 will create another user. Could be a surprise for the user.
				- with the externalAuth set to oauth2 we say the user "you are
				about to change the email but that will invalidate login with oauth2 providers asssociated with that email"
					- we do not list the providers, it could be many if user hast same email by many.
	- if user uses many oauth2 providers (with same email) we do not update avatar, name etc
			- after first login/register the name avatar is appropieated by the app. in the future it can or can not be edited
	- we could allow delete password, only having alternative login nmethod like oauth2.
	- double pasword, oauth2?
		- only through request-password-reset 
	- when first auth-with-oauth2, ie register with oauth2, we do not allow it if email not validated by oauth2 provider
		- oauth2 registration always produce verified true
	- db methods shoudl not make validation, handlers should make it, like create user with verified and no password.

- mapping go struct <=> sqlite queries (insert queries, only those use default)
	- using crawshaw Exec only allow for determined number of placeholder
	- example a insert for createUser, we want sqlite to write the default created, updated. but the go struct is empty
		- each method (query) should write all values in go 
		- each method determine the list of arguments, which argumetn will update, and the number of placeholders.
			- createUser for oauth2
				- created and updated do not write

			- createUser for password
				- created and updated do not write
	- i think the idea is
		- check the schema definition, look for DEFAULT in schema that are not zero
			- if schema has a default it means it wants to write it, let it
		- for each query, method, determine which values come from go, and which ones are writen by the db
		- it should check all posssible callers of the method
			- oauth2 creation of user has avatar, password no -> but default is fine argument
			- all creation we let dn write
		- normally if the zero value in go is not the zero value in db. do not let go write it.*as always we are taking about INSERTS)

- POST handlers that always run. ancapsulate alice.
    - h.WithMiddlewareChain(chain1).WithMiddleware(m1,m2).WithMiddlewareChain(chain2).WithObservers(o1,o2)

    - NewMiddlewareChain(a,b,c,d)
    - Bind() // Bind to handler
    - BindPostHandlers()
    - WithObservers
    - mainChain = handler.WithMiddleware(a,b,c) or
    - mainChain = handler.WithMiddleware(middlewareChain)
    - finalHandler := WithObservers(mainChain, handlerB, handlerC, handlerD)
    - h.WithMiddleware().WitObservers
    - 
- refresh jwt
- User schema, remove tokenKey
- jwt signing key invalidation
