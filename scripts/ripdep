#!/bin/bash
# ripdep - Deployment and operations tool
# Primary location: Local dev machine
# Orchestrates operations on remote servers via a dedicated remote script

set -euo pipefail

# ============================================ 
# CONFIGURATION
# ============================================ 

# Base directory on remote hosts for staging deployments.
REMOTE_BASE_DIR="/tmp"

# Local directory for storing final release artifacts (tarballs).
RELEASES_BASE_DIR="${HOME}/src/backup/releases"
# Local directory containing project-specific configuration files.
CONFIG_BASE_DIR="${HOME}/src/restinpieces-litestream"
# Directory for hook scripts that can be run at different stages.
HOOKS_DIR="${CONFIG_BASE_DIR}/hooks"

# External Tool Configurations
REPO_LITESTREAM="benbjohnson/litestream"
REPO_RIPC="caasmo/restinpieces"
# just for build process
REPO_AGE="FiloSottile/age"
URL_SQLITE_TOOLS="https://sqlite.org/2025/sqlite-tools-linux-x64-3510100.zip"

# Binary naming convention
# Binary is now named after the project.

# Toold URL Templates
# Litestream: %s=repo, %s=tag, %s=version_num
URL_TEMPLATE_LITESTREAM="https://github.com/%s/releases/download/%s/litestream-%s-linux-x86_64.tar.gz"
# Age: %s=repo, %s=tag, %s=tag
URL_TEMPLATE_AGE="https://github.com/%s/releases/download/%s/age-%s-linux-amd64.tar.gz"
# Ripc: %s=repo, %s=tag, %s=tag
URL_TEMPLATE_RIPC="https://github.com/%s/releases/download/%s/ripc-%s-linux-amd64.tar.gz"
URL_SERVICE_TEMPLATE="https://raw.githubusercontent.com/caasmo/restinpieces/master/restinpieces.service"

# Filename template for the tarball
TARBALL_FILENAME_TEMPLATE="%s-%s.tar.gz"

# Colors for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
NC=$'\033[0m' # No Color

# ============================================ 
# UTILITY FUNCTIONS
# ============================================ 

log_info() {
    echo -e "${BLUE}→${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

require_root() {
    if [ $EUID -ne 0 ]; then
        log_error "This command must run as root (use sudo)"
        exit 1
    fi
}

# Get the latest release tag from a GitHub repository
get_latest_release() {
    local repo=$1
    local url="https://api.github.com/repos/${repo}/releases/latest"
    local version
    
    if ! version=$(curl -sSf "$url" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/'); then
        log_error "Failed to fetch latest release for $repo"
        return 1
    fi
    
    if [[ -z "$version" ]]; then
        log_error "Empty version returned for $repo"
        return 1
    fi
    
    echo "$version"
}

# get_latest_tag: Returns the latest git tag if available, otherwise the short commit hash.
get_latest_tag() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not a git repository. Cannot determine version."
        return 1
    fi

    local tag
    if tag=$(git describe --tags --abbrev=0 2>/dev/null); then
        echo "$tag"
        return 0
    fi
    
    local hash
    if hash=$(git rev-parse --short HEAD 2>/dev/null); then
        echo "$hash"
        return 0
    fi

    log_error "Failed to get git tag or commit hash."
    return 1
}

get_project_name_from_file_base() {
    local input_string="$1"
    echo "${input_string%-*}"
}

get_version_from_file_base() {
    local input_string="$1"
    echo "${input_string##*-}"
}

get_remote_dir_from_tarball_path() {
    local tarball_path=$1
    local tarball_name=$(basename "$tarball_path")
    local tar_base="${tarball_name%.tar.gz}"

    local project_name=$(get_project_name_from_file_base "$tar_base")
    local version=$(get_version_from_file_base "$tar_base")

    if [ -z "$project_name" ] || [ -z "$version" ]; then
        log_error "Could not parse project name and version from tarball: ${tarball_name}"
        return 1
    fi

    echo "${REMOTE_BASE_DIR}/${project_name}/${version}"
}

seems_build_dir() {
    local dir=$1
    [ -d "${dir}/bin" ] && [ -d "${dir}/data" ]
}

is_go_project() {
    local project_path=$1
    if [ ! -d "$project_path" ]; then
        log_error "Project path does not exist or is not a directory: ${project_path}"
        return 1
    fi
    if [ ! -f "${project_path}/go.mod" ]; then
        log_error "Not a Go project (missing go.mod): ${project_path}"
        return 1
    fi
    if [ ! -d "${project_path}/cmd" ]; then
        log_error "No cmd/ directory found in project: ${project_path}"
        return 1
    fi
    return 0
}

# ============================================ 
# DEPLOYMENT FUNCTIONS - LOCAL
# ============================================ 

setup_build_dir() {
    local build_dir=$1 bin_dir=$2 data_dir=$3
    if [ -d "$build_dir" ]; then
        log_info "Deleting old build directory: $build_dir"
        rm -rf "$build_dir"
    fi
    mkdir -p "$bin_dir"
    mkdir -p "$data_dir"
}

build_project_binary() {
    local bin_dir=$1 project_path=$2 binary_name=$3
    local project_name=$(basename "$project_path")
    log_info "Building Go restinpieces app binaries from project: $project_path"

    local num_commands=$(ls -d "$project_path"/cmd/*/ 2>/dev/null | wc -l)
    local src=""

    if [ -d "$project_path/cmd/$project_name" ]; then
        src="./cmd/$project_name"
    elif [ "$num_commands" -eq 1 ]; then
        local full_path=$(ls -d "$project_path"/cmd/*/ 2>/dev/null)
        local cmd_name=$(basename "$full_path")
        src="./cmd/$cmd_name"
    else
        log_error "Build failed: Multiple dirs in cmd/ but none match '${project_name}', or cmd/ is empty."
        exit 1
    fi
    
    (cd "$project_path" && go build -ldflags="-s -w" -trimpath -o "${bin_dir}/${binary_name}" "$src")
    log_success "Built ${binary_name} in ${bin_dir}"
}

download_litestream() {
    local bin_dir=$1 ls_version ls_version_num url_ls
    if ! ls_version=$(get_latest_release "$REPO_LITESTREAM"); then return 1; fi
    log_info "Downloading Litestream ${ls_version}..."
    ls_version_num=${ls_version#v}
    printf -v url_ls "$URL_TEMPLATE_LITESTREAM" "$REPO_LITESTREAM" "$ls_version" "$ls_version_num"
    if ! curl -sSLf "$url_ls" | tar -xz -C "${bin_dir}" litestream; then return 1; fi
    chmod +x "${bin_dir}/litestream"
}

download_age() {
    local bin_dir=$1 age_version url_age
    if ! age_version=$(get_latest_release "$REPO_AGE"); then return 1; fi
    log_info "Downloading Age ${age_version}..."
    printf -v url_age "$URL_TEMPLATE_AGE" "$REPO_AGE" "$age_version" "$age_version"
    if ! curl -sSLf "$url_age" | tar -xz -C "${bin_dir}" --strip-components=1 "age/age-keygen" "age/age"; then return 1; fi
}

download_ripc() {
    local bin_dir=$1 ripc_version url_ripc
    if ! ripc_version=$(get_latest_release "$REPO_RIPC"); then return 1; fi
    log_info "Downloading Ripc ${ripc_version}..."
    printf -v url_ripc "$URL_TEMPLATE_RIPC" "$REPO_RIPC" "$ripc_version" "$ripc_version"
    if ! curl -sSLf "$url_ripc" | tar -xz -C "${bin_dir}" --strip-components=1 ripc/ripc; then return 1; fi
}

download_sqlite() {
    local bin_dir=$1 tmp_zip
    log_info "Downloading SQLite tools..."
    tmp_zip=$(mktemp --suffix=.zip)
    if ! curl -sSLf "$URL_SQLITE_TOOLS" -o "$tmp_zip"; then return 1; fi
    if ! unzip -p "$tmp_zip" "sqlite3" > "${bin_dir}/sqlite3"; then return 1; fi
    chmod +x "${bin_dir}/sqlite3"
    rm -f "$tmp_zip"
}

generate_age_key() {
    local bin_dir=$1 build_dir=$2
    log_info "Generating Age key..."
    "${bin_dir}/age-keygen" -o "${build_dir}/age.key"
}

create_app_db() {
    local bin_dir=$1 build_dir=$2 data_dir=$3
    log_info "Creating app.db..."
    if [ -f "${data_dir}/app.db" ]; then exit 1; fi
    "${bin_dir}/ripc" -agekey "${build_dir}/age.key" -dbpath "${data_dir}/app.db" app create
}

add_litestream_configuration() {
    local project_name=$1 bin_dir=$2 build_dir=$3 data_dir=$4
    local config_file="${CONFIG_BASE_DIR}/${project_name}/litestream.yml"
    if [ -f "$config_file" ]; then
        log_info "Importing Litestream config..."
        "${bin_dir}/ripc" -agekey "${build_dir}/age.key" -dbpath "${data_dir}/app.db" config save -scope litestream "$config_file"
    fi
}

add_systemd_configuration() {
    local project_name=$1 build_dir=$2
    log_info "Adding Systemd configuration..."
    local dest_service_file="${build_dir}/systemd-${project_name}.service"
    local local_service_path="${CONFIG_BASE_DIR}/${project_name}/${project_name}.service"

    if [ -f "$local_service_path" ]; then
        cp "$local_service_path" "$dest_service_file"
    else
        curl -sSLf "$URL_SERVICE_TEMPLATE" -o "$dest_service_file"
    fi
    sed -i "s#\${RESTINPIECES_APP}#${project_name}#g" "$dest_service_file"
    if ! grep -q "${project_name}" "$dest_service_file"; then exit 1; fi
}

generate_remote_script() {
    local output_path=$1
    cat > "$output_path" <<'REMOTE_SCRIPT_EOF'
#!/bin/bash
set -euo pipefail

RED=$'\033[0;31m'; GREEN=$'\033[0;32m'; YELLOW=$'\033[1;33m'; BLUE=$'\033[0;34m'; NC=$'\033[0m'
log_info() { echo -e "${BLUE}→${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1" >&2; }
require_root() { if [ $EUID -ne 0 ]; then log_error "Must run as root"; exit 1; fi; }

create_service_user() {
    log_info "Setting up user: ${project_name}"
    if id "${project_name}" &>/dev/null; then return 0; fi
    useradd -r -m -d "/home/${project_name}" -s /bin/bash "${project_name}"
}

create_directory_structure() {
    local data_dir="/home/${project_name}/data"
    mkdir -p "/home/${project_name}/bin" "$data_dir" "/home/${project_name}/logs"
    chmod 700 "$data_dir"
    chown -R "${project_name}:${project_name}" "/home/${project_name}"
}

deploy_binaries() {
    local source_dir=$1
    for binary in "${source_dir}"/bin/*; do
        if [ -f "$binary" ]; then
            local base=$(basename "$binary")
            install -m 700 -o "${project_name}" -g "${project_name}" "$binary" "/home/${project_name}/bin/${base}"
        fi
    done
}

deploy_data_files() {
    local source_dir=$1
    if [ -f "${source_dir}/age.key" ]; then
        install -m 600 -o "${project_name}" -g "${project_name}" "${source_dir}/age.key" "/home/${project_name}/age.key"
    fi
    if [ ! -d "${source_dir}/data" ]; then return 0; fi
    for datafile in "${source_dir}"/data/*; do
        if [ -f "$datafile" ]; then
            local base=$(basename "$datafile")
            install -m 600 -o "${project_name}" -g "${project_name}" "$datafile" "/home/${project_name}/data/${base}"
        fi
    done
}

deploy_systemd_service() {
    local source_dir=$1
    local service_file=$(find "${source_dir}" -name "systemd-${project_name}.service" | head -n 1)
    cp "$service_file" "/etc/systemd/system/${project_name}.service"
    systemctl daemon-reload
}

cmd_install() {
    require_root
    local script_path=$(realpath "$0")
    local source_dir=$(dirname "$(dirname "$script_path")")
    local project_name=$(basename "$(dirname "$source_dir")")
    log_info "Installing service '${project_name}'..."
    create_service_user
    create_directory_structure
    deploy_binaries "$source_dir"
    deploy_data_files "$source_dir"
    deploy_systemd_service "$source_dir"
    log_success "Installation complete! To start: systemctl enable --now ${project_name}"
}

cmd_uninstall() {
    require_root
    local service_name=${1:-}
    if [ -z "$service_name" ]; then echo "Usage: $0 uninstall <name>"; exit 1; fi
    log_info "Uninstalling '${service_name}'..."
    if systemctl list-unit-files "${service_name}.service" >/dev/null 2>&1; then
        if systemctl is-active --quiet "${service_name}"; then systemctl stop "${service_name}"; fi
        if systemctl is-enabled --quiet "${service_name}"; then systemctl disable "${service_name}"; fi
    fi
    rm -f "/etc/systemd/system/${service_name}.service"
    systemctl daemon-reload
    if id "${service_name}" &>/dev/null; then userdel -r "${service_name}"; fi
    log_success "Uninstalled '${service_name}'."
}

main() {
    local cmd=${1:-}
    shift
    case "$cmd" in
        install) cmd_install "$@" ;;
        uninstall) cmd_uninstall "$@" ;;
        *) exit 1 ;;
    esac
}
main "$@"
REMOTE_SCRIPT_EOF
    chmod +x "$output_path"
}

# ============================================ 
# DEPLOYMENT FUNCTIONS - REMOTE TRANSFER
# ============================================ 

cmd_pack() {
    local build_dir=$1
    if [ -z "$build_dir" ] || [ ! -d "$build_dir" ]; then exit 1; fi
    if ! seems_build_dir "$build_dir"; then exit 1; fi
    local build_name=$(basename "$build_dir") 
    local project_name=$(get_project_name_from_file_base "$build_name")
    local output_path="${RELEASES_BASE_DIR}/${project_name}/${build_name}.tar.gz"
    mkdir -p "$(dirname "$output_path")"
    tar -czf "$output_path" -C "$build_dir" .
    log_success "Created release artifact: ${output_path}"
    if [ -z "${CMD_DEPLOY_CALLER:-}" ]; then
        log_info "Next step: ripdep push <host> ${output_path}"
    fi
}

cmd_push() {
    local host=${1:-} tarball_path=${2:-}
    if [ -z "$host" ] || [ -z "$tarball_path" ]; then exit 1; fi
    local remote_dir=$(get_remote_dir_from_tarball_path "$tarball_path")
    local tarball_name=$(basename "$tarball_path")
    ssh "${host}" "mkdir -p ${remote_dir}"
    scp "$tarball_path" "${host}:${remote_dir}/"
    ssh "${host}" "tar -xzf ${remote_dir}/${tarball_name} -C ${remote_dir}"
    log_success "Uploaded to ${remote_dir}"
    if [ -z "${CMD_DEPLOY_CALLER:-}" ]; then
        log_info "Next step: ssh ${host} sudo ${remote_dir}/bin/rip-remote install"
    fi
}

cmd_deploy() {
    local host=${1:-} build_dir=${2:-}
    if [ -z "$host" ] || [ -z "$build_dir" ]; then exit 1; fi
    shift 2; local install_args="$*"
    CMD_DEPLOY_CALLER=true cmd_pack "$build_dir"
    local build_name=$(basename "$build_dir")
    local project_name=$(get_project_name_from_file_base "$build_name")
    local tarball_path="${RELEASES_BASE_DIR}/${project_name}/${build_name}.tar.gz"
    CMD_DEPLOY_CALLER=true cmd_push "$host" "$tarball_path"
    local remote_dir=$(get_remote_dir_from_tarball_path "$tarball_path")
    ssh -t "${host}" "sudo ${remote_dir}/bin/rip-remote install ${install_args}"
    log_success "Deployment complete on ${host}!"
}

cmd_undeploy() {
    local host=${1:-} service_name=${2:-} force=${3:-}
    if [ -z "$host" ] || [ -z "$service_name" ]; then exit 1; fi
    if [[ "$force" != "-y" && "$force" != "--force" ]]; then
        log_warning "PERMANENTLY DELETE '${service_name}' from '${host}'?"
        read -p "(yes/no) " -r; if [[ ! "$REPLY" =~ ^[Yy][Ee][Ss]$ ]]; then exit 1; fi
    fi
    local remote_tmp="/tmp/rip-remote-uninstall-$$"
    ssh -t "${host}" "sudo cp /home/${service_name}/bin/rip-remote ${remote_tmp} && sudo ${remote_tmp} uninstall ${service_name} && sudo rm -f ${remote_tmp}"
    log_success "Successfully undeployed '${service_name}' from '${host}'."
}

# ============================================ 
# OPERATIONAL COMMANDS
# ============================================ 

remote_dir_exists() { ssh "${1}" "[ -d '${2}' ]"; }
create_remote_backup() { ssh "${1}" "sudo tar -czf '/tmp/${3}' -C '/home/${2}' ."; }
download_remote_backup() { scp "${1}:${2}" "${3}"; }
cleanup_remote_backup() { ssh "${1}" "sudo rm -f '${2}'"; }

backup_remote_service() {
    local host=$1 service_name=$2
    local bkp="${service_name}-bkp-$(date +%Y%m%d).tar.gz"
    if remote_dir_exists "$host" "/home/${service_name}"; then
        create_remote_backup "$host" "$service_name" "$bkp"
        download_remote_backup "$host" "/tmp/${bkp}" "."
        cleanup_remote_backup "$host" "/tmp/${bkp}"
        log_success "Backup saved locally: ${bkp}"
    fi
}

cmd_backup() {
    if [ -z "${1:-}" ] || [ -z "${2:-}" ]; then exit 1; fi
    backup_remote_service "$1" "$2"
}

cmd_maintenance() {
    local host=$1 mode=$2
    ssh -t "${host}" "sudo systemctl $([ "$mode" == "on" ] && echo "stop" || echo "start") ${service_name}"
}

cmd_config() { ssh -t "${1}" "sudo -u ${project_name} /home/${project_name}/bin/ripc ${@:2}"; }
cmd_status() { ssh -t "${1}" "systemctl status ${project_name} --no-pager"; }
cmd_logs() { ssh -t "${1}" "journalctl -u ${project_name} -n ${2:-50} -f"; }
cmd_restart() { ssh -t "${1}" "sudo systemctl restart ${project_name}"; }
cmd_db_status() { ssh -t "${1}" "ls -lh /home/${project_name}/data/*.db"; }

# ============================================ 
# MAIN ENTRY POINT
# ============================================ 

cmd_build-release() {
    local build_base=$1 proj_path=$2
    is_go_project "$proj_path" || exit 1
    local name=$(basename "$proj_path")
    local ver=$(cd "$proj_path" && get_latest_tag)
    local build_dir="${build_base}/${name}-${ver}"
    setup_build_dir "$build_dir" "${build_dir}/bin" "${build_dir}/data"
    build_project_binary "${build_dir}/bin" "$proj_path" "$name"
    generate_remote_script "${build_dir}/bin/rip-remote"
    download_ripc "${build_dir}/bin"
    log_success "Release build: ${build_dir}"
}

cmd_build-bootstrap() {
    local build_base=$1 proj_path=$2
    is_go_project "$proj_path" || exit 1
    local name=$(basename "$proj_path")
    local ver=$(cd "$proj_path" && get_latest_tag)
    local build_dir="${build_base}/${name}-${ver}"
    local tmp=$(mktemp -d); trap 'rm -rf "$tmp"' RETURN
    setup_build_dir "$build_dir" "${build_dir}/bin" "${build_dir}/data"
    build_project_binary "${build_dir}/bin" "$proj_path" "$name"
    generate_remote_script "${build_dir}/bin/rip-remote"
    download_ripc "${build_dir}/bin"
    download_age "$tmp"
    generate_age_key "$tmp" "$build_dir"
    create_app_db "${build_dir}/bin" "$build_dir" "${build_dir}/data"
    add_litestream_configuration "$name" "${build_dir}/bin" "$build_dir" "${build_dir}/data"
    add_systemd_configuration "$name" "$build_dir"
    log_success "Bootstrap build: ${build_dir}"
}

show_help() {
    cat <<EOF
ripdep - Operations tool
Commands: build-release, build-bootstrap, pack, push, deploy, undeploy, backup, status, logs, restart
EOF
}

main() {
    local cmd=${1:-}
    shift || true
    case "$cmd" in
        build-release) cmd_build-release "$@" ;;
        build-bootstrap) cmd_build-bootstrap "$@" ;;
        pack) cmd_pack "$@" ;; push) cmd_push "$@" ;;
        deploy) cmd_deploy "$@" ;; undeploy) cmd_undeploy "$@" ;;
        backup) cmd_backup "$@" ;; status) cmd_status "$@" ;;
        logs) cmd_logs "$@" ;; restart) cmd_restart "$@" ;;
        help|--help|-h) show_help ;;
        *) show_help; exit 1 ;;
    esac
}
main "$@"