#!/bin/bash
# ripdep - Deployment and operations tool
# Primary location: Local dev machine
# Orchestrates operations on remote servers via a dedicated remote script

set -euo pipefail

# ============================================ 
# CONFIGURATION
# ============================================ 

# Base directory on remote hosts for staging deployments.
REMOTE_BASE_DIR="/tmp"

# Local directory for storing final release artifacts (tarballs).
RELEASES_BASE_DIR="${HOME}/src/backup/releases"
# Local directory containing project-specific configuration files.
CONFIG_BASE_DIR="${HOME}/src/restinpieces-litestream"
# Directory for hook scripts that can be run at different stages.
HOOKS_DIR="${CONFIG_BASE_DIR}/hooks"

# External Tool Configurations
REPO_LITESTREAM="benbjohnson/litestream"
REPO_RIPC="caasmo/restinpieces"
# just for build process
REPO_AGE="FiloSottile/age"
URL_SQLITE_TOOLS="https://sqlite.org/2025/sqlite-tools-linux-x64-3510100.zip"

# Binary naming convention
# Binary is now named after the project.

# Toold URL Templates
# Litestream: %s=repo, %s=tag, %s=version_num
URL_TEMPLATE_LITESTREAM="https://github.com/%s/releases/download/%s/litestream-%s-linux-x86_64.tar.gz"
# Age: %s=repo, %s=tag, %s=tag
URL_TEMPLATE_AGE="https://github.com/%s/releases/download/%s/age-%s-linux-amd64.tar.gz"
# Ripc: %s=repo, %s=tag, %s=tag
URL_TEMPLATE_RIPC="https://github.com/%s/releases/download/%s/ripc-%s-linux-amd64.tar.gz"
URL_SERVICE_TEMPLATE="https://raw.githubusercontent.com/caasmo/restinpieces/master/restinpieces.service"

# Filename template for the tarball
TARBALL_FILENAME_TEMPLATE="%s-%s.tar.gz"

# Colors for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
NC=$'\033[0m' # No Color

# ============================================ 
# UTILITY FUNCTIONS
# ============================================ 

log_info() {
    echo -e "${BLUE}→${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

require_root() {
    if [ $EUID -ne 0 ]; then
        log_error "This command must run as root (use sudo)"
        exit 1
    fi
}

# Get the latest release tag from a GitHub repository
#
# return 1 for Function Errors
# Variable Declaration Separation, this ensures exit codes are properly captured.
# Explicit Error Checking Where Needed
get_latest_release() {
    local repo=$1
    local url="https://api.github.com/repos/${repo}/releases/latest"
    local version
    
    # Fetch version from GitHub API
    if ! version=$(curl -sSf "$url" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/'); then
        log_error "Failed to fetch latest release for $repo"
        return 1
    fi
    
    # Validate we got a version
    if [[ -z "$version" ]]; then
        log_error "Empty version returned for $repo"
        return 1
    fi
    
    echo "$version"
}

# get_latest_tag: Returns the latest git tag if available, otherwise the short commit hash.
# Echos the tag/hash on success and returns 0.
# On failure, logs an error and returns 1.
get_latest_tag() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not a git repository. Cannot determine version."
        return 1
    fi

    local tag
    if tag=$(git describe --tags --abbrev=0 2>/dev/null); then
        echo "$tag"
        return 0
    fi
    
    local hash
    if hash=$(git rev-parse --short HEAD 2>/dev/null); then
        echo "$hash"
        return 0
    fi

    log_error "Failed to get git tag or commit hash."
    return 1
}

get_project_name_from_file_base() {
    # This function extracts the project name from a string like "my-project-v1.0".
    # It assumes the format is "<project-name>-<version>".
    #
    # The magic is "%-"* (Shortest Suffix Removal). It finds the LAST hyphen
    # and removes it and everything after it, leaving the project name.
    # Example: "my-project-with--v0.1" % "-*" --> "my-project-with-"
    local input_string="$1"
    echo "${input_string%-*}"
}

get_version_from_file_base() {
    # This function extracts the version from a string like "my-project-v1.0".
    # It assumes the format is "<project-name>-<version>".
    #
    # The magic is "##*-" (Longest Prefix Removal). It finds everything from
    # the start of the string up to and including the LAST hyphen. It removes
    # this prefix, leaving only the version string.
    # Example: "my-project-with--v0.1" ## "*-" --> "v0.1"
    local input_string="$1"
    echo "${input_string##*-}"
}

get_remote_dir_from_tarball_path() {
    local tarball_path=$1
    local tarball_name
    tarball_name=$(basename "$tarball_path")
    local tar_base="${tarball_name%.tar.gz}"

    local project_name
    project_name=$(get_project_name_from_file_base "$tar_base")
    local version
    version=$(get_version_from_file_base "$tar_base")

    if [ -z "$project_name" ] || [ -z "$version" ]; then
        log_error "Could not parse project name and version from tarball: ${tarball_name}"
        log_error "Expected format: <project-name>-<version>.tar.gz"
        return 1
    fi

    echo "${REMOTE_BASE_DIR}/${project_name}/${version}"
}

# seems_build_dir: returns 0 if the directory has bin/ and data/ subdirs.
seems_build_dir() {
    local dir=$1
    [ -d "${dir}/bin" ] && [ -d "${dir}/data" ]
}

# is_go_project: Checks if a given path is a valid Go project for this script.
# Returns 0 if it is, 1 otherwise.
is_go_project() {
    local project_path=$1
    if [ ! -d "$project_path" ]; then
        log_error "Project path does not exist or is not a directory: ${project_path}"
        return 1
    fi
    if [ ! -f "${project_path}/go.mod" ]; then
        log_error "Not a Go project (missing go.mod): ${project_path}"
        return 1
    fi
    # The build logic relies on a cmd/ dir.
    if [ ! -d "${project_path}/cmd" ]; then
        log_error "No cmd/ directory found in project: ${project_path}"
        return 1
    fi
    return 0
}

# ============================================ 
# DEPLOYMENT FUNCTIONS - LOCAL
# ============================================ 

setup_build_dir() {
    local build_dir=$1
    local bin_dir=$2
    local data_dir=$3
    
    # Clean and create
    if [ -d "$build_dir" ]; then
        log_info "Deleting old build directory: $build_dir"
        rm -rf "$build_dir"
    fi
    mkdir -p "$bin_dir"
    mkdir -p "$data_dir"
    
    log_info "Build directory created: $build_dir"
}

build_project_binary() {
    local bin_dir=$1 project_path=$2 binary_name=$3
    local project_name
    project_name=$(basename "$project_path")
    log_info "Building Go restinpieces app binaries from project: $project_path"

    local num_commands
    num_commands=$(ls -d "$project_path"/cmd/*/ 2>/dev/null | wc -l)
    local src=""

    if [ -d "$project_path/cmd/$project_name" ]; then
        src="./cmd/$project_name"
    elif [ "$num_commands" -eq 1 ]; then
        # Get the single cmd subdirectory
        local full_path
        full_path=$(ls -d "$project_path"/cmd/*/ 2>/dev/null)
        local cmd_name
        cmd_name=$(basename "$full_path")
        src="./cmd/$cmd_name"
    else
        log_error "Build failed: Multiple dirs in cmd/ but none match '${project_name}', or cmd/ is empty."
        exit 1
    fi
    
    # Build from the project directory.
    # We use a subshell (...) to change into the project dir for the build (so go.mod is found)
    # without affecting the current working directory of this script.
    (cd "$project_path" && go build -ldflags="-s -w" -trimpath -o "${bin_dir}/${binary_name}" "$src")
    log_success "Built ${binary_name} in ${bin_dir}"
}

# Download and install Litestream binary
download_litestream() {
    local bin_dir=$1
    local ls_version
    local ls_version_num
    local url_ls
    
    # Get latest version
    if ! ls_version=$(get_latest_release "$REPO_LITESTREAM"); then
        log_error "Failed to fetch latest Litestream version."
        return 1
    fi
    
    log_info "Downloading Litestream ${ls_version}..."
    
    # Strip 'v' prefix if present
    ls_version_num=${ls_version#v}
    
    # Build download URL
    printf -v url_ls "$URL_TEMPLATE_LITESTREAM" "$REPO_LITESTREAM" "$ls_version" "$ls_version_num"
    
    # Download and extract (pipefail ensures curl failures are caught)
    if ! curl -sSLf "$url_ls" | tar -xz -C "${bin_dir}" litestream; then
        log_error "Failed to download or extract Litestream from $url_ls" >&2
        return 1
    fi
    
    # Make executable
    chmod +x "${bin_dir}/litestream"
    
    log_success "Litestream binary placed in ${bin_dir}/litestream"
}

# Download and install Age encryption binaries
download_age() {
    local bin_dir=$1
    local age_version
    local url_age
    
    # Get latest version
    if ! age_version=$(get_latest_release "$REPO_AGE"); then
        log_error "Failed to fetch latest Age version."
        return 1
    fi
    
    log_info "Downloading Age ${age_version}..."
    
    # Build download URL
    printf -v url_age "$URL_TEMPLATE_AGE" "$REPO_AGE" "$age_version" "$age_version"
    
    # Download and extract
    if ! curl -sSLf "$url_age" | tar -xz -C "${bin_dir}" --strip-components=1 "age/age-keygen" "age/age"; then
        log_error "Failed to download or extract Age from $url_age" >&2
        return 1
    fi
    
    log_success "Age binaries placed in ${bin_dir}"
}

# Download and install Ripc binary
download_ripc() {
    local bin_dir=$1
    local ripc_version
    local url_ripc
    
    # Get latest version
    if ! ripc_version=$(get_latest_release "$REPO_RIPC"); then
        log_error "Failed to fetch latest Ripc version."
        return 1
    fi
    
    log_info "Downloading Ripc ${ripc_version}..."
    
    # Build download URL
    printf -v url_ripc "$URL_TEMPLATE_RIPC" "$REPO_RIPC" "$ripc_version" "$ripc_version"
    
    # Download and extract
    if ! curl -sSLf "$url_ripc" | tar -xz -C "${bin_dir}" --strip-components=1 ripc/ripc; then
        log_error "Failed to download or extract Ripc from $url_ripc" >&2
        return 1
    fi
    
    log_success "Ripc binary placed in ${bin_dir}/ripc"
}

# Download and install SQLite tools
download_sqlite() {
    local bin_dir=$1
    local tmp_zip
    
    log_info "Downloading SQLite tools from $URL_SQLITE_TOOLS..."
    
    # Create temporary file
    tmp_zip=$(mktemp --suffix=.zip)
    
    # Download SQLite tools
    if ! curl -sSLf "$URL_SQLITE_TOOLS" -o "$tmp_zip"; then
        log_error "Failed to download SQLite tools from $URL_SQLITE_TOOLS" >&2
        return 1
    fi
    
    # Extract sqlite3 binary to bin_dir
    if ! unzip -p "$tmp_zip" "sqlite3" > "${bin_dir}/sqlite3"; then
        log_error "Failed to extract sqlite3 from archive" >&2
        return 1
    fi
    
    # Make executable
    chmod +x "${bin_dir}/sqlite3"
    
    # Clean up temp file
    rm -f "$tmp_zip"
    
    log_success "SQLite tools downloaded to ${bin_dir}/sqlite3"
}

generate_age_key() {
    local bin_dir=$1
    local build_dir=$2
    
    log_info "Generating Age key..."
    "${bin_dir}/age-keygen" -o "${build_dir}/age.key"
    log_success "Generated age.key in ${build_dir}/age.key"
}

create_app_db() {
    local bin_dir=$1
    local build_dir=$2
    local data_dir=$3
    
    log_info "Creating app.db..."
    if [ -f "${data_dir}/app.db" ]; then
        log_warning "app.db already exists in build dir"
        exit 1
    fi
    
    "${bin_dir}/ripc" -agekey "${build_dir}/age.key" -dbpath "${data_dir}/app.db" app create
    log_success "Created app.db in ${data_dir}/app.db"
}

add_litestream_configuration() {
    local project_name=$1
    local bin_dir=$2
    local build_dir=$3
    local data_dir=$4
    
    local config_file="${CONFIG_BASE_DIR}/${project_name}/litestream.yml"

    log_info "Checking Litestream configuration..."
    if [ -f "$config_file" ]; then
        log_info "Importing Litestream config from: $config_file"
        "${bin_dir}/ripc" -agekey "${build_dir}/age.key" -dbpath "${data_dir}/app.db" config save -scope litestream "$config_file"
        log_success "Added ${config_file} to config store in ${data_dir}/app.db"
    else
        log_warning "Build has no litestream support (config file not found at $config_file)"
    fi
}

add_systemd_configuration() {
    local project_name=$1
    local build_dir=$2
    
    log_info "Adding Systemd configuration..."
    
    local dest_service_file="${build_dir}/systemd-${project_name}.service"
    local local_service_path="${CONFIG_BASE_DIR}/${project_name}/${project_name}.service"

    # Check for a local service file first
    if [ -f "$local_service_path" ]; then
        log_info "Found local systemd service file template at: $local_service_path"
        cp "$local_service_path" "$dest_service_file"
        log_success "Copied local service file template to $dest_service_file"
    else
        log_warning "Local systemd service file template not found at $local_service_path"
        log_info "Downloading service template from $URL_SERVICE_TEMPLATE..."
        if curl -sSLf "$URL_SERVICE_TEMPLATE" -o "$dest_service_file"; then
             log_success "Downloaded service template to $dest_service_file"
        else
             log_error "Failed to download service template from $URL_SERVICE_TEMPLATE"
             exit 1
        fi
    fi
    
    # Substitute variable
    sed -i "s#\\\${RESTINPIECES_APP}#${project_name}#g" "$dest_service_file"

    # The binary is now named after the project, which matches the systemd template's
    # expectation of /bin/${project_name}. No substitution is needed.
    
    # Validation: Ensure the service name appears in the file
    if ! grep -q "${project_name}" "$dest_service_file"; then
        log_error "Validation failed: Service name '${project_name}' not found in prepared service file ${dest_service_file}"
        exit 1
    fi
    
    log_success "Service name '${project_name}' substituted into systemd unit file at $dest_service_file"
}

# generate_remote_script: Creates a dedicated, lean executor for remote operations.
#
# Design Insight:
# This function generates a self-contained shell script ('rip-remote') that is
# packaged with the application. This script contains only the logic necessary
# for execution on the remote server (installing, uninstalling, user setup).
#
# This architecture provides a clean separation of concerns: 'ripdep' remains
# a local orchestrator, while 'rip-remote' acts as the secure on-server executor.
generate_remote_script() {
    local output_path=$1
    
    # NOTE: Using a fully quoted heredoc ('REMOTE_SCRIPT_EOF') is critical. It 
    # prevents the local shell from expanding variables like ${project_name}, 
    # ensuring they are preserved literally for runtime evaluation on the server.
    cat > "$output_path" <<'REMOTE_SCRIPT_EOF'
#!/bin/bash
set -euo pipefail

# ============================================ 
# UTILITY FUNCTIONS (Remote)
# ============================================ 

# Colors for output
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
NC=$'\033[0m' # No Color

log_info() {
    echo -e "${BLUE}→${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

require_root() {
    if [ $EUID -ne 0 ]; then
        log_error "This command must run as root (use sudo)"
        exit 1
    fi
}

# ============================================ 
# INSTALLATION FUNCTIONS (Remote)
# ============================================ 

create_service_user() {
    log_info "Setting up service user: ${project_name}..."
    
    if id "${project_name}" &>/dev/null; then
        log_success "User ${project_name} already exists"
        return 0
    fi
    
    useradd -r -m -d "/home/${project_name}" -s /bin/bash "${project_name}"
    log_success "Created user ${project_name}"
}

create_directory_structure() {
    log_info "Creating directory structure..."
    
    local data_dir="/home/${project_name}/data"
    local dirs=(
        "/home/${project_name}/bin"
        "$data_dir"
        "/home/${project_name}/logs"
    )
    
    for dir in "${dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            log_success "Created $dir"
        fi
    done
    
    chmod 700 "$data_dir"
    log_success "Set permissions for ${data_dir} to 700"
    
    chown -R "${project_name}:${project_name}" "/home/${project_name}"
}

deploy_binaries() {
    local source_dir=$1
    log_info "Deploying binaries from ${source_dir}/bin..."
    
    if [ ! -d "${source_dir}/bin" ]; then
        log_error "No bin/ directory found in ${source_dir}"
        exit 1
    fi

    for binary in "${source_dir}"/bin/*;
    do
        if [ -f "$binary" ]; then
            local basename=$(basename "$binary")
            install -m 700 -o "${project_name}" -g "${project_name}" \
                "$binary" "/home/${project_name}/bin/${basename}"
            log_success "Installed binary: ${basename} to /home/${project_name}/bin/${basename}"
        fi
    done
}

deploy_data_files() {
    local source_dir=$1
    log_info "Deploying data files from ${source_dir}/data..."
    
    # Deploy age key if present
    if [ -f "${source_dir}/age.key" ]; then
        local dest_key="/home/${project_name}/age.key"
        install -m 600 -o "${project_name}" -g "${project_name}" \
            "${source_dir}/age.key" "$dest_key"
        log_success "Installed age.key to $dest_key"
    fi

    if [ ! -d "${source_dir}/data" ]; then
        return 0
    fi
    
    for datafile in "${source_dir}"/data/*;
    do
        if [ -f "$datafile" ]; then
            local basename=$(basename "$datafile")
            local dest="/home/${project_name}/data/${basename}"
            
            install -m 600 -o "${project_name}" -g "${project_name}" \
                "$datafile" "$dest"
            log_success "Installed data file: ${basename} to $dest"
        fi
    done
}

deploy_systemd_service() {
    local source_dir=$1
    log_info "Deploying systemd service..."
    
    # Find generated service file
    local service_file=$(find "${source_dir}" -name "systemd-${project_name}.service" | head -n 1)
    
    if [ -z "$service_file" ]; then
        log_error "Service file not found in ${source_dir}"
        exit 1
    fi
    
    cp "$service_file" "/etc/systemd/system/${project_name}.service"
    systemctl daemon-reload
    log_success "Deployed ${project_name}.service to /etc/systemd/system/${project_name}.service"
}

handle_database() {
    # Placeholder for future logic
    :
}

cmd_install() {
    require_root
    
    # --- CONTEXT INTROSPECTION ---
    # The script determines its context from its own execution path ($0),
    # which is expected to be inside the extracted archive.
    # e.g., /tmp/myproject/v1.2.0/bin/rip-remote
    local script_path=$(realpath "$0")
    local source_dir=$(dirname "$(dirname "$script_path")")
    local project_name=$(basename "$(dirname "$source_dir")")

    log_info "Installing service '${project_name}' from source '${source_dir}'..."

    local restore_from_backup=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --restore-from-backup)
                restore_from_backup=true
                shift
                ;; 
            *)
                shift
                ;; 
        esac
    done
    
    create_service_user
    create_directory_structure
    deploy_binaries "$source_dir"
    deploy_data_files "$source_dir"
    deploy_systemd_service "$source_dir"
    handle_database
    
    log_success "Installation complete!"
    log_info "To start service: systemctl enable --now ${project_name}"
}

# ============================================ 
# UNINSTALLATION FUNCTIONS (Remote)
# ============================================ 

stop_service() {
    log_info "Stopping and disabling service '${service_name}'..."
    if systemctl list-unit-files "${service_name}.service" >/dev/null 2>&1; then
        if systemctl is-active --quiet "${service_name}"; then
            log_info "→ Service is active. Stopping..."
            systemctl stop "${service_name}"
        fi
        if systemctl is-enabled --quiet "${service_name}"; then
            log_info "→ Service is enabled. Disabling..."
            systemctl disable "${service_name}"
        fi
    else
        log_warning "→ Service ${service_name}.service not found, skipping stop/disable."
    fi
    log_success "Service stop/disable phase finished."
}

remove_systemd_service() {
    local service_path="/etc/systemd/system/${service_name}.service"
    log_info "Deleting systemd service file for '${service_name}'..."
    if [ -f "${service_path}" ]; then
        log_info "→ Removing systemd service file: ${service_path}"
        rm -f "${service_path}"
        systemctl daemon-reload
    else
        log_warning "→ Service file ${service_path} not found."
    fi
    log_success "Systemd file cleanup finished."
}

delete_service_user() {
    log_info "Deleting user and all files for '${service_name}'..."
    if id "${service_name}" &>/dev/null; then
        log_info "→ Deleting user '${service_name}' and home directory..."
        userdel -r "${service_name}"
    else
        log_warning "→ User ${service_name} not found."
    fi
    log_success "User and files cleanup finished."
}

cmd_uninstall() {
    require_root
    local service_name=${1:-} # Used by helpers

    if [ -z "$service_name" ]; then
        echo "Usage: $0 uninstall <service-name>"
        exit 1
    fi

    log_info "Uninstalling service '${service_name}'..."

    stop_service
    remove_systemd_service
    delete_service_user

    log_success "Successfully uninstalled '${service_name}'."
}

# ============================================ 
# MAIN (Remote)
# ============================================ 
main() {
    local cmd=${1:-}
    if [ -z "$cmd" ]; then
        log_error "No command provided to remote script."
        exit 1
    fi
    shift
    
    case "$cmd" in
        install) cmd_install "$@" ;; 
        uninstall) cmd_uninstall "$@" ;; 
        *) 
            log_error "Unknown remote command: $cmd"
            exit 1 
            ;; 
    esac
}

main "$@"
REMOTE_SCRIPT_EOF

    chmod +x "$output_path"
    log_success "Generated remote execution script at ${output_path}"
}

# ============================================ 
# DEPLOYMENT FUNCTIONS - REMOTE TRANSFER
# ============================================ 

# cmd_pack: Packages a build directory into a release tarball.
#
# General Purpose:
# This function takes a completed build directory and creates a compressed tarball (.tar.gz).
# The resulting tarball is placed in the RELEASES_BASE_DIR.
#
# Tarball Naming:
# The name of the output tarball is primarily determined by the main project binary found
# in the build directory's 'bin/' subfolder. It includes the project name and the Git tag version.
cmd_pack() {
    local build_dir=$1

    if [ -z "$build_dir" ] || [ ! -d "$build_dir" ]; then
        log_error "Usage: $0 pack <build_dir>"
        exit 1
    fi

    if ! seems_build_dir "$build_dir"; then
        log_error "Directory '${build_dir}' does not appear to be a valid build directory."
        exit 1
    fi
    
    log_info "Packing build directory: ${build_dir}"

    local build_name=$(basename "$build_dir") 
    local project_name=$(get_project_name_from_file_base "$build_name")
    local output_dir="${RELEASES_BASE_DIR}/${project_name}"
    mkdir -p "$output_dir"
    local output_path="${output_dir}/${build_name}.tar.gz"
    
    log_info "Creating tarball: ${output_path}"
    if ! tar -czf "$output_path" -C "$build_dir" .;
    then
         log_error "Failed to create tarball."
         exit 1
    fi
    
    local size=$(du -h "$output_path" | cut -f1)
    log_success "Created release artifact: ${output_path} (${size})"

    if [ -z "${CMD_DEPLOY_CALLER:-}" ]; then
        echo ""
        log_info "Next step: Push the artifact to a remote host:"
        log_info "    $0 push <host> ${output_path}"
    fi
}

# cmd_push: Transfers and extracts a release tarball to a remote host.
#
# Design Insight:
# This function is the transport layer of the deployment pipeline. It stages the
# release in a temporary, version-specific directory on the remote host.
cmd_push() {
    local host=${1:-}
    local tarball_path=${2:-}

    if [ -z "$host" ] || [ -z "$tarball_path" ]; then
        log_error "Usage: $0 push <host> <tarball_path>"
        exit 1
    fi

    if [ ! -f "$tarball_path" ]; then
        log_error "Tarball not found at: ${tarball_path}"
        exit 1
    fi
    
    local remote_dir=$(get_remote_dir_from_tarball_path "$tarball_path")
    local tarball_name=$(basename "$tarball_path")

    log_info "Uploading ${tarball_path} to ${host}:${remote_dir}..."
    ssh -o LogLevel=ERROR "${host}" "mkdir -p ${remote_dir}"
    scp "$tarball_path" "${host}:${remote_dir}/"
    
    log_info "Extracting on remote..."
    if ! ssh -o LogLevel=ERROR "${host}" "tar -xzf ${remote_dir}/${tarball_name} -C ${remote_dir}"; then
        log_error "Failed to extract tarball on remote host"
        exit 1
    fi
    
    log_success "Uploaded and extracted to ${remote_dir}"
    
    if [ -z "${CMD_DEPLOY_CALLER:-}" ]; then
        echo ""
        log_info "Next step: Log in to the remote machine and run the installer:"
        log_info "    ssh ${host}"
        log_info "    sudo ${remote_dir}/bin/rip-remote install"
    fi
}

# cmd_deploy: Orchestrates the pack, push, and remote install sequence.
cmd_deploy() {
    local host=${1:-}
    local build_dir=${2:-}

    if [ -z "$host" ] || [ -z "$build_dir" ]; then
        log_error "Usage: $0 deploy <host> <build_dir> [install-options...]"
        exit 1
    fi

    shift 2; local install_args="$*"

    log_info "Step 1: Packing application locally..."
    CMD_DEPLOY_CALLER=true cmd_pack "$build_dir"

    local build_name=$(basename "$build_dir")
    local project_name=$(get_project_name_from_file_base "$build_name")
    local tarball_path="${RELEASES_BASE_DIR}/${project_name}/${build_name}.tar.gz"
    
    log_info "Step 2: Pushing application to ${host}..."
    CMD_DEPLOY_CALLER=true cmd_push "$host" "$tarball_path"

    log_info "Step 3: Installing application on ${host}..."
    local remote_dir=$(get_remote_dir_from_tarball_path "$tarball_path")
    ssh -t -o LogLevel=ERROR "${host}" "sudo ${remote_dir}/bin/rip-remote install ${install_args}"
    
    log_success "Deployment complete on ${host}!"
}

# cmd_undeploy: Permanently removes a service from a host.
cmd_undeploy() {
    local host=${1:-}
    local service_name=${2:-}
    local force=${3:-}

    if [ -z "$host" ] || [ -z "$service_name" ]; then
        log_error "Usage: $0 undeploy <host> <service-name> [-y|--force]"
        exit 1
    fi

    if [[ "$force" != "-y" && "$force" != "--force" ]]; then
        log_warning "This will PERMANENTLY DELETE the service '${service_name}' from '${host}'."
        log_warning "Consider creating a backup first with the 'backup' command."
        read -p "Are you sure? (yes/no) " -r
        if [[ ! "$REPLY" =~ ^[Yy][Ee][Ss]$ ]]; then exit 1; fi
    fi

    log_info "Uninstalling application on ${host}..."
    local deployed_script_path="/home/${service_name}/bin/rip-remote"
    local remote_tmp_script_path="/tmp/rip-remote-uninstall-$$".$RANDOM

    local uninstall_script="set -e
sudo cp ${deployed_script_path} ${remote_tmp_script_path}
sudo chmod +x ${remote_tmp_script_path}
sudo ${remote_tmp_script_path} uninstall ${service_name}
sudo rm -f ${remote_tmp_script_path}"
    
    if ! ssh -t -o LogLevel=ERROR "${host}" "$uninstall_script"; then
        log_error "Remote uninstall failed."
        exit 1
    fi
    
    log_success "Successfully undeployed '${service_name}' from '${host}'."
}

# ============================================ 
# OPERATIONAL COMMANDS
# ============================================ 

remote_dir_exists() { ssh -o LogLevel=ERROR "${1}" "[ -d '${2}' ]"; }
create_remote_backup() { ssh -t -o LogLevel=ERROR "${1}" "sudo tar -czf '/tmp/${3}' -C '/home/${2}' ."; }
download_remote_backup() { scp "${1}:/tmp/${2}" "${3}"; }
cleanup_remote_backup() { ssh -t -o LogLevel=ERROR "${1}" "sudo rm -f '/tmp/${2}'"; }

# backup_remote_service: Creates and downloads a backup archive of a remote service.
backup_remote_service() {
    local host=$1 service_name=$2
    local bkp_name="${service_name}-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
    if remote_dir_exists "$host" "/home/${service_name}"; then
        create_remote_backup "$host" "$service_name" "$bkp_name"
        download_remote_backup "$host" "$bkp_name" "."
        cleanup_remote_backup "$host" "$bkp_name"
        log_success "Backup saved locally to: ${PWD}/${bkp_name}"
    else
        log_warning "Remote home directory not found, skipping backup."
    fi
}

cmd_backup() {
    if [ -z "${1:-}" ] || [ -z "${2:-}" ]; then
        log_error "Usage: $0 backup <host> <service-name>"; exit 1
    fi
    backup_remote_service "$1" "$2"
}

cmd_status() { ssh -t -o LogLevel=ERROR "${1}" "systemctl status ${2} --no-pager"; }
cmd_logs() { ssh -t -o LogLevel=ERROR "${1}" "journalctl -u ${2} -n ${3:-50} -f"; }
cmd_restart() { ssh -t -o LogLevel=ERROR "${1}" "sudo systemctl restart ${2}"; }

# ============================================ 
# MAIN ENTRY POINT
# ============================================ 

# cmd_build-release: Builds a standard release artifact from source code.
cmd_build-release() {
    local build_base_dir=$1 project_path=$2
    if ! is_go_project "$project_path"; then exit 1; fi
    local project_name=$(basename "$project_path")
    local version=$(cd "$project_path" && get_latest_tag)
    local build_dir="${build_base_dir}/${project_name}-${version}"
    
    setup_build_dir "$build_dir" "${build_dir}/bin" "${build_dir}/data"
    build_project_binary "${build_dir}/bin" "$project_path" "$project_name"
    generate_remote_script "${build_dir}/bin/rip-remote"
    download_ripc "${build_dir}/bin"
    log_success "Release build completed in: ${build_dir}"
}

# cmd_build-bootstrap: Builds a bootstrap artifact with keys and database.
cmd_build-bootstrap() {
    local build_base_dir=$1 project_path=$2
    if ! is_go_project "$project_path"; then exit 1; fi
    local project_name=$(basename "$project_path")
    local version=$(cd "$project_path" && get_latest_tag)
    local build_dir="${build_base_dir}/${project_name}-${version}"
    
    # very tricky behavior of trap:
    # - In bash, RETURN traps bubble up. Always stop bubbling up in the caller.
    local tmp_tools=$(mktemp -d); trap 'rm -rf "$tmp_tools"' RETURN

    setup_build_dir "$build_dir" "${build_dir}/bin" "${build_dir}/data"
    build_project_binary "${build_dir}/bin" "$project_path" "$project_name"
    generate_remote_script "${build_dir}/bin/rip-remote"
    download_ripc "${build_dir}/bin"
    download_age "$tmp_tools"
    generate_age_key "$tmp_tools" "$build_dir"
    create_app_db "${build_dir}/bin" "$build_dir" "${build_dir}/data"
    add_litestream_configuration "$project_name" "${build_dir}/bin" "$build_dir" "${build_dir}/data"
    add_systemd_configuration "$project_name" "$build_dir"
    log_success "Bootstrap build completed in: ${build_dir}"
}

show_help() {
    cat <<EOF
${GREEN}ripdep${NC} - Deployment and operations tool

Usage: $0 <COMMAND> [ARGS...]

Commands:
  build-release <build_dir> <project_path>   Build release artifact.
  build-bootstrap <build_dir> <project_path> Build bootstrap artifact.
  pack <build_dir>                           Package build into tarball.
  push <host> <tarball_path>                 Upload tarball to host.
  deploy <host> <build_dir>                  Pack, push, and install.
  undeploy <host> <service-name>             Remove service and data.
  backup <host> <service-name>               Download backup archive.
  status <host> <service-name>               Check service status.
  logs <host> <service-name> [lines]         Tail service logs.
  restart <host> <service-name>              Restart service.
EOF
}

main() {
    local cmd=${1:-}; if [ -z "$cmd" ]; then show_help; exit 0; fi
    shift || true
    case "$cmd" in
        build-release) cmd_build-release "$@" ;; 
        build-bootstrap) cmd_build-bootstrap "$@" ;; 
        pack) cmd_pack "$@" ;; push) cmd_push "$@" ;; 
        deploy) cmd_deploy "$@" ;; undeploy) cmd_undeploy "$@" ;; 
        backup) cmd_backup "$@" ;; status) cmd_status "$@" ;; 
        logs) cmd_logs "$@" ;; restart) cmd_restart "$@" ;; 
        help|--help|-h) show_help ;; 
        *) log_error "Unknown command: $cmd"; exit 1 ;; 
    esac
    trap - RETURN
}

main "$@"
